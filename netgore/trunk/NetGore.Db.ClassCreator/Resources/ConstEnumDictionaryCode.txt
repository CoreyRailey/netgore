/// <summary>
/// A Dictionary-like lookup table for the Enum values of the type collection `[COLUMNCOLLECTIONNAME]` for the
/// table that this class represents. Majority of the code for this class was automatically generated and
/// only other automatically generated code should be using this class.
/// </summary>
private class [CLASSNAME] : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<[KEYTYPE], [VALUETYPE]>>, IPersistable
{
    /// <summary>
    /// Name of the node that contains all the values.
    /// </summary>
    const string _valuesNodeName = "Values";

    /// <summary>
    /// Name of the key for the value's key.
    /// </summary>
    const string _keyKeyName = "Key";

    /// <summary>
    /// Name of the key for the value's value.
    /// </summary>
    const string _valueKeyName = "Value";
    
    /// <summary>
    /// Array that takes in the enum's value (casted to an int) as the array index, and spits out the
    /// corresponding index for the instanced <see name="_values"/> array. This allows us to build an array
    /// of values without wasting any indicies even if the defined enum skips values.
    /// </summary>
    static readonly int[] _enumToValueIndex;

    /// <summary>
    /// Array that takes in the <see cref="_values"/> array index and spits out the enum value that the
    /// index is for. This is to allow for a reverse-lookup on the <see cref="_enumToValueIndex"/>.
    /// </summary>
    static readonly [KEYTYPE][] _valueIndexToKey;

    /// <summary>
    /// The total number of unique defined enum values. Each instanced <see cref="_values"/> array
    /// will have a length equal to this value.
    /// </summary>
    static readonly int _numEnumValues;

    /// <summary>
    /// Array containing the actual values. The index of this array is found through the value returned
    /// from the _lookupTable.
    /// </summary>
    readonly [VALUETYPE][] _values;

    /// <summary>
    /// Initializes the <see cref="[CLASSNAME]"/> class.
    /// </summary>
    static [CLASSNAME]()
    {
        _valueIndexToKey = EnumHelper<[KEYTYPE]>.Values.ToArray();
        _numEnumValues = _valueIndexToKey.Length;
        _enumToValueIndex = new int[EnumHelper<[KEYTYPE]>.MaxValue + 1];

        for (int i = 0; i < _valueIndexToKey.Length; i++)
        {
            var key = (int)_valueIndexToKey[i];
            _enumToValueIndex[key] = i;
        }
    }
    
    /// <summary>
    /// Initializes a new instance of the <see cref="[CLASSNAME]"/> class.
    /// </summary>
    public [CLASSNAME]()
    {
        _values = new int[_numEnumValues];
    }
    
    /// <summary>
    /// Gets or sets an item's value using the <paramref name="key"/>.
    /// </summary>
    /// <param name="key">The key for the value to get or set.</param>
    /// <returns>The item's value for the corresponding <paramref name="key"/>.</returns>
    public [VALUETYPE] this[[KEYTYPE] key]
    {
        get { return _values[_enumToValueIndex[(int)key]]; }
        set { _values[_enumToValueIndex[(int)key]] = value; }
    }

    #region IEnumerable<KeyValuePair<[KEYTYPE],[VALUETYPE]>> Members

    /// <summary>
    /// Returns an enumerator that iterates through the collection.
    /// </summary>
    /// <returns>
    /// A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
    /// </returns>
    public IEnumerator<KeyValuePair<[KEYTYPE], [VALUETYPE]>> GetEnumerator()
    {
        for (int i = 0; i < _values.Length; i++)
        {
            yield return new KeyValuePair<[KEYTYPE], [VALUETYPE]>(_valueIndexToKey[i], _values[i]);
        }
    }

    /// <summary>
    /// Returns an enumerator that iterates through a collection.
    /// </summary>
    /// <returns>
    /// An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
    /// </returns>
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    #endregion

    /// <summary>
    /// Reads the state of the object from an <see cref="IValueReader"/>. Values should be read in the exact
    /// same order as they were written.
    /// </summary>
    /// <param name="reader">The <see cref="IValueReader"/> to read the values from.</param>
    public void ReadState(IValueReader reader)
    {
        // Zero all the existing values
        for (int i = 0; i < _values.Length; i++)
            _values[i] = default([VALUETYPE]);

        // Read and set the values
        var values = reader.ReadManyNodes<KeyValuePair<[KEYTYPE], [VALUETYPE]>>(_valuesNodeName, ReadValueHandler);
        foreach (var value in values)
        {
            this[value.Key] = value.Value;
        }
    }

    /// <summary>
    /// Writes the state of the object to an <see cref="IValueWriter"/>.
    /// </summary>
    /// <param name="writer">The <see cref="IValueWriter"/> to write the values to.</param>
    public void WriteState(IValueWriter writer)
    {
        writer.WriteManyNodes(_valuesNodeName, this.Where(x => x.Value != default([VALUETYPE])), WriteValueHandler);
    }

    /// <summary>
    /// Reads a <see cref="KeyValuePair{Key, Value}"/>.
    /// </summary>
    /// <param name="reader">The <see cref="IValueReader"/> to read from.</param>
    /// <returns>The read <see cref="KeyValuePair{Key, Value}"/>.</returns>
    static KeyValuePair<[KEYTYPE], [VALUETYPE]> ReadValueHandler(IValueReader reader)
    {
        var key = reader.ReadEnum<[KEYTYPE]>(_keyKeyName);
        var value = reader.[VALUEREADERREADMETHOD](_valueKeyName);
        return new KeyValuePair<[KEYTYPE], [VALUETYPE]>(key, value);
    }

    /// <summary>
    /// Writes a <see cref="KeyValuePair{Key, Value}"/>.
    /// </summary>
    /// <param name="writer">The <see cref="IValueWriter"/> to write to.</param>
    /// <param name="value">The <see cref="KeyValuePair{Key, Value}"/> to write.</param>
    static void WriteValueHandler(IValueWriter writer, KeyValuePair<[KEYTYPE], [VALUETYPE]> value)
    {
        writer.WriteEnum(_keyKeyName, value.Key);
        writer.Write(_valueKeyName, value.Value);
    }
}