//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace NetGore.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "10.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("// The distance multiplier to apply to the values unpacked from channels to get t" +
            "he offset. This decreases our resolution,\r\n// giving us a choppier image, but in" +
            "creases our range. Lower values give higher resolution but require smaller dista" +
            "nces.\r\n// This MUST be the same in all the refraction effects!\r\nconst float Dist" +
            "anceMultiplier = 2.0;\r\n\r\n// The value of the reflection channels that will be us" +
            "ed to not perform any reflection. Having this non-zero allows us to\r\n// reflect " +
            "in both directions instead of just borrowing pixels in one direction. Of course," +
            " this also halves our max distance.\r\n// Logically, this value is 1/2. However, a" +
            " slightly different number is used due to the behavior of floating-point numbers" +
            ".\r\n// This MUST be the same in all the refraction effects!\r\nconst float BaseOffs" +
            "et = 0.4981;\r\n\r\n// The maximum alpha value allowed.\r\nconst float MaxAlpha = 1.00" +
            ";\r\n\r\n// The alpha multiplier. Greater values keep at MaxAlpha for longer, but fa" +
            "de out much faster.\r\n// Too low of values will just end up not reaching MaxAlpha" +
            ", or not reaching it for long.\r\nconst float AlphaMultiplier = 2.0;\r\n\r\n// A multi" +
            "plier used on the distortion vector values to determine the intensity. A value o" +
            "f 1.0f will result\r\n// in using a distortion equal to that in the source noise i" +
            "mage. Its recommended you manually edit the noise\r\n// texture\'s R and G channels" +
            " to alter the intensity, but this value can still be used to give different inte" +
            "nsities\r\n// to the same texture.\r\nuniform float Intensity = 0.1;\r\n\r\n// The maxim" +
            "um expected age of the effect. Unit does not matter as long as it is consistent." +
            "\r\nuniform float MaxAge = 2000.0;\r\n\r\n// The current age of the effect. Unit does " +
            "not matter as long as it is consistent.\r\nuniform float Age;\r\n\r\n// The texture us" +
            "ed to generate the noise.\r\nuniform sampler2D NoiseTexture;\r\n\r\nvoid main (void)\r\n" +
            "{\r\n\tvec4 noiseVec;\r\n\tvec2 noiseXYVec;\r\n\tfloat a;\r\n\r\n\t// Get the noise from the t" +
            "exture\r\n\tnoiseVec = texture2D(NoiseTexture, gl_TexCoord[0].st);\r\n\r\n\t// Calculate" +
            " the noise vector\r\n\tnoiseXYVec = (noiseVec.xy / DistanceMultiplier) * Intensity;" +
            "\r\n\r\n\t// Calculate the alpha, which will let us fade out smoothly before the effe" +
            "ct ends\r\n\ta = clamp(noiseVec.a * AlphaMultiplier * ((MaxAge - Age) / MaxAge), 0." +
            "0f, MaxAlpha);\r\n\r\n\t// Apply the coloring, using the transformation directly and " +
            "unaltered from the noise texture\r\n\tgl_FragColor = vec4(noiseXYVec.x, noiseXYVec." +
            "y, 0.0f, a);\r\n}")]
        public string ExplosionRefractionEffectShader {
            get {
                return ((string)(this["ExplosionRefractionEffectShader"]));
            }
        }
        
        [global::System.Configuration.ApplicationScopedSettingAttribute()]
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Configuration.DefaultSettingValueAttribute("\r\n// The distance multiplier to apply to the values unpacked from channels to get" +
            " the offset. This decreases our resolution,\r\n// giving us a choppier image, but " +
            "increases our range. Lower values give higher resolution but require smaller dis" +
            "tances.\r\n// This MUST be the same in all the refraction effects!\r\nconst float Di" +
            "stanceMultiplier = 2.0;\r\n\r\n// The value of the reflection channels that will be " +
            "used to not perform any reflection. Having this non-zero allows us to\r\n// reflec" +
            "t in both directions instead of just borrowing pixels in one direction. Of cours" +
            "e, this also halves our max distance.\r\n// Logically, this value is 1/2. However," +
            " a slightly different number is used due to the behavior of floating-point numbe" +
            "rs.\r\n// This MUST be the same in all the refraction effects!\r\nconst float BaseOf" +
            "fset = 0.4981;\r\n\r\n// The texture used to create the waves.\r\nuniform sampler2D Wa" +
            "veNoiseTexture;\r\n\r\n// The intensity of the waves. Greater value = higher intensi" +
            "ty. Changing the wave noise texture itself is also\r\n// a good way to go about al" +
            "tering the intensity and just the overall pattern of the waves.\r\nuniform float W" +
            "aveIntensity = 0.01;\r\n\r\n// The current time in milliseconds.\r\nuniform float Time" +
            ";\r\n\r\n// The wave speed multiplier. The greater the value, the faster the waves m" +
            "ove.\r\nuniform float WaveSpeedMultiplier = 0.5;\r\n\r\n// The alpha value of the wate" +
            "r. A lower alpha makes the water less transparent, making it harder to see the o" +
            "riginal\r\n// graphics under it. This is just a modifier of the alpha of the wave " +
            "noise texture, allowing you to give different\r\n// alpha values without having to" +
            " change the texture.\r\nuniform float WaterAlphaModifier = 0.38;\r\n\r\n// The ratio o" +
            "f the size of the drawn image over the height of the texture. That is, DrawHeigh" +
            "t / TextureHeight.\r\n// For example, if you draw a 512x512 texture with a size of" +
            " 256x256 pixels, this value will be 0.5f.\r\nuniform float DrawTextureHeightRatio;" +
            "\r\n\r\n// The amount to magnify the water\'s refraction. 0.5f results in the images " +
            "in the water being twice the height of\r\n// the real world (and thus shows half t" +
            "he world), while 2.0f results in images in the water being half the height\r\n// o" +
            "f the real world (and shows twice as much).\r\nuniform float Magnification = 1.0;\r" +
            "\n\r\nvoid main (void)\r\n{\r\n\tvec4 noiseVec;\r\n\tvec2 waveNoiseOffsetVec;\r\n\tvec2 newRG;" +
            "\r\n    float refractValue;\r\n\r\n\t// Get the noise vector for the waves, using the t" +
            "ime so we can move, and mod to stay in the range of (0.0f, 1.0f).\r\n\twaveNoiseOff" +
            "setVec = mod(gl_TexCoord[0].st + (Time * 0.0005f * WaveSpeedMultiplier), 1.0f);\r" +
            "\n\r\n\t// Add the noise from the waves.\r\n\tnoiseVec = texture2D(WaveNoiseTexture, wa" +
            "veNoiseOffsetVec).rgba;\r\n\r\n\t// Calculate the red and green channels in the same " +
            "way. Simply, we take the base offset then add the noise from the water.\r\n\tnewRG " +
            "= BaseOffset + (noiseVec.rg * WaveIntensity);\r\n\r\n\t// For the vertical offset, we" +
            " also need to add the texture offset, which allows us to properly reflect. Addin" +
            "g is used\r\n\t// because we reflect what is above us.\r\n    refractValue = (gl_TexC" +
            "oord[0].y * DrawTextureHeightRatio) / DistanceMultiplier;\r\n\tnewRG.y += refractVa" +
            "lue * (1.0 + Magnification);\r\n\r\n\t// Clamp it all into the range of (0.0f, 1.0f)\r" +
            "\n\tnewRG = clamp(newRG, 0.0f, 1.0f);\r\n\r\n\t// Apply the color.\r\n\tgl_FragColor = vec" +
            "4(newRG.x, newRG.y, 0.0f, clamp(noiseVec.a - WaterAlphaModifier, 0.0f, 1.0f));\r\n" +
            "}\r\n// The distance multiplier to apply to the values unpacked from channels to g" +
            "et the offset. This decreases our resolution,\r\n// giving us a choppier image, bu" +
            "t increases our range. Lower values give higher resolution but require smaller d" +
            "istances.\r\n// This MUST be the same in all the refraction effects!\r\nconst float " +
            "DistanceMultiplier = 2.0;\r\n\r\n// The value of the reflection channels that will b" +
            "e used to not perform any reflection. Having this non-zero allows us to\r\n// refl" +
            "ect in both directions instead of just borrowing pixels in one direction. Of cou" +
            "rse, this also halves our max distance.\r\n// Logically, this value is 1/2. Howeve" +
            "r, a slightly different number is used due to the behavior of floating-point num" +
            "bers.\r\n// This MUST be the same in all the refraction effects!\r\nconst float Base" +
            "Offset = 0.4981;\r\n\r\n// The texture used to create the waves.\r\nuniform sampler2D " +
            "WaveNoiseTexture;\r\n\r\n// The intensity of the waves. Greater value = higher inten" +
            "sity. Changing the wave noise texture itself is also\r\n// a good way to go about " +
            "altering the intensity and just the overall pattern of the waves.\r\nuniform float" +
            " WaveIntensity = 0.01;\r\n\r\n// The current time in milliseconds.\r\nuniform float Ti" +
            "me;\r\n\r\n// The wave speed multiplier. The greater the value, the faster the waves" +
            " move.\r\nuniform float WaveSpeedMultiplier = 0.5;\r\n\r\n// The alpha value of the wa" +
            "ter. A lower alpha makes the water less transparent, making it harder to see the" +
            " original\r\n// graphics under it. This is just a modifier of the alpha of the wav" +
            "e noise texture, allowing you to give different\r\n// alpha values without having " +
            "to change the texture.\r\nuniform float WaterAlphaModifier = 0.38;\r\n\r\n// The ratio" +
            " of the size of the drawn image over the height of the texture. That is, DrawHei" +
            "ght / TextureHeight.\r\n// For example, if you draw a 512x512 texture with a size " +
            "of 256x256 pixels, this value will be 0.5f.\r\nuniform float DrawTextureHeightRati" +
            "o;\r\n\r\n// The amount to magnify the water\'s refraction. 0.5f results in the image" +
            "s in the water being twice the height of\r\n// the real world (and thus shows half" +
            " the world), while 2.0f results in images in the water being half the height\r\n//" +
            " of the real world (and shows twice as much).\r\nuniform float Magnification = 1.0" +
            ";\r\n\r\nvoid main (void)\r\n{\r\n\tvec4 noiseVec;\r\n\tvec2 waveNoiseOffsetVec;\r\n\tvec2 newR" +
            "G;\r\n    float refractValue;\r\n\r\n\t// Get the noise vector for the waves, using the" +
            " time so we can move, and mod to stay in the range of (0.0f, 1.0f).\r\n\twaveNoiseO" +
            "ffsetVec = mod(gl_TexCoord[0].st + (Time * 0.0005f * WaveSpeedMultiplier), 1.0f)" +
            ";\r\n\r\n\t// Add the noise from the waves.\r\n\tnoiseVec = texture2D(WaveNoiseTexture, " +
            "waveNoiseOffsetVec).rgba;\r\n\r\n\t// Calculate the red and green channels in the sam" +
            "e way. Simply, we take the base offset then add the noise from the water.\r\n\tnewR" +
            "G = BaseOffset + (noiseVec.rg * WaveIntensity);\r\n\r\n\t// For the vertical offset, " +
            "we also need to add the texture offset, which allows us to properly reflect. Add" +
            "ing is used\r\n\t// because we reflect what is above us.\r\n    refractValue = (gl_Te" +
            "xCoord[0].y * DrawTextureHeightRatio) / DistanceMultiplier;\r\n\tnewRG.y += refract" +
            "Value * (1.0 + Magnification);\r\n\r\n\t// Clamp it all into the range of (0.0f, 1.0f" +
            ")\r\n\tnewRG = clamp(newRG, 0.0f, 1.0f);\r\n\r\n\t// Apply the color.\r\n\tgl_FragColor = v" +
            "ec4(newRG.x, newRG.y, 0.0f, clamp(noiseVec.a - WaterAlphaModifier, 0.0f, 1.0f));" +
            "\r\n}")]
        public string WaterRefractionEffectShader {
            get {
                return ((string)(this["WaterRefractionEffectShader"]));
            }
        }
    }
}
